<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Minni Viewer</title>
		<link rel="stylesheet" href="/styles.css" />
		<!-- Marked for markdown rendering -->
		<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
		<!-- DOMPurify for XSS sanitization -->
		<script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
		<!-- Prism for syntax highlighting -->
		<link
			rel="stylesheet"
			href="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/themes/prism-tomorrow.min.css"
		/>
		<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/prism.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-typescript.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-javascript.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-bash.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-json.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-sql.min.js"></script>
	</head>
	<body>
		<div class="container">
			<!-- Header -->
			<header class="header">
				<h1>Minni Viewer</h1>
				<div class="stats" id="stats">Loading...</div>
			</header>

			<!-- Tabs -->
			<nav class="tabs">
				<button class="tab active" data-tab="canvas">Canvas</button>
				<button class="tab" data-tab="db">Database</button>
			</nav>

			<!-- Canvas Tab -->
			<main class="content" id="canvas-tab">
				<div class="canvas-header">
					<span class="status" id="canvas-status">Waiting for content...</span>
					<button class="btn" id="save-to-minni" disabled>Save to Minni</button>
				</div>
				<div class="canvas-content" id="canvas-content">
					<div class="empty-state">
						<p>The LLM can send markdown here using <code>minni_canvas</code></p>
						<p>Content will appear in real-time</p>
					</div>
				</div>
			</main>

			<!-- DB Tab -->
			<main class="content hidden" id="db-tab">
				<div class="db-controls">
					<select id="table-select">
						<option value="memories">Memories</option>
						<option value="projects">Projects</option>
						<option value="tasks">Tasks</option>
					</select>
					<select id="project-filter">
						<option value="">All Projects</option>
					</select>
					<button class="btn" id="refresh-db">Refresh</button>
				</div>
				<div class="db-content" id="db-content">
					<div class="empty-state">Select a table to view data</div>
				</div>
				<!-- Memory detail modal -->
				<div class="modal hidden" id="memory-modal">
					<div class="modal-content">
						<button class="modal-close" id="modal-close">&times;</button>
						<div id="memory-detail"></div>
					</div>
				</div>
			</main>
		</div>

		<script>
			// === State ===
			let currentTab = "canvas";
			let canvasContent = "";
			let projects = [];

			// === DOM Elements ===
			const $ = (sel) => document.querySelector(sel);
			const $$ = (sel) => document.querySelectorAll(sel);

			// === Tabs ===
			$$(".tab").forEach((tab) => {
				tab.addEventListener("click", () => {
					const tabName = tab.dataset.tab;

					// Update active tab
					$$(".tab").forEach((t) => t.classList.remove("active"));
					tab.classList.add("active");

					// Show/hide content
					$("#canvas-tab").classList.toggle("hidden", tabName !== "canvas");
					$("#db-tab").classList.toggle("hidden", tabName !== "db");

					currentTab = tabName;

					// Load data if switching to DB tab
					if (tabName === "db") {
						loadProjects();
						loadTableData();
					}
				});
			});

			// === Canvas SSE ===
			function connectCanvasSSE() {
				const eventSource = new EventSource("/canvas/stream");

				eventSource.onmessage = (event) => {
					const data = JSON.parse(event.data);
					if (data.content) {
						canvasContent = data.content;
						renderCanvas(data.content);
						$("#canvas-status").textContent =
							`Updated ${new Date(data.timestamp).toLocaleTimeString()}`;
						$("#save-to-minni").disabled = false;
					}
				};

				eventSource.onerror = () => {
					$("#canvas-status").textContent = "Disconnected. Reconnecting...";
					setTimeout(connectCanvasSSE, 2000);
				};
			}

			function renderCanvas(markdown) {
				const rawHtml = marked.parse(markdown);
				const cleanHtml = DOMPurify.sanitize(rawHtml);
				$("#canvas-content").innerHTML = cleanHtml;
				// Highlight code blocks
				$$("#canvas-content pre code").forEach((block) => {
					Prism.highlightElement(block);
				});
			}

			// === Stats ===
			async function loadStats() {
				try {
					const res = await fetch("/db/stats");
					const stats = await res.json();
					$("#stats").innerHTML = `
          <span>Memories: ${stats.memories}</span>
          <span>Projects: ${stats.projects}</span>
          <span>Tasks: ${stats.tasks}</span>
        `;
				} catch (e) {
					$("#stats").textContent = "Error loading stats";
				}
			}

			// === DB Tab ===
			async function loadProjects() {
				try {
					const res = await fetch("/db/projects");
					projects = await res.json();

					const select = $("#project-filter");
					select.innerHTML = '<option value="">All Projects</option>';
					projects.forEach((p) => {
						select.innerHTML += `<option value="${p.id}">${p.name}</option>`;
					});
				} catch (e) {
					console.error("Error loading projects:", e);
				}
			}

			async function loadTableData() {
				const table = $("#table-select").value;
				const projectId = $("#project-filter").value;

				let url = `/db/${table}`;
				if (projectId) {
					url += `?project=${projectId}`;
				}

				try {
					const res = await fetch(url);
					const data = await res.json();
					renderTable(table, data);
				} catch (e) {
					$("#db-content").innerHTML = `<div class="error">Error loading data: ${e.message}</div>`;
				}
			}

			function renderTable(table, data) {
				if (!data.length) {
					$("#db-content").innerHTML = '<div class="empty-state">No data found</div>';
					return;
				}

				// Define columns based on table
				const columns = {
					memories: ["id", "type", "title", "status", "permission", "updatedAt"],
					projects: ["id", "name", "status", "stack", "updatedAt"],
					tasks: ["id", "title", "priority", "status", "updatedAt"],
				};

				const cols = columns[table] || Object.keys(data[0]);

				let html = "<table><thead><tr>";
				cols.forEach((col) => {
					html += `<th>${col}</th>`;
				});
				html += "</tr></thead><tbody>";

				data.forEach((row) => {
					html += "<tr>";
					cols.forEach((col) => {
						let val = row[col];

						// Format timestamps
						if (col === "updatedAt" || col === "createdAt") {
							val = val ? new Date(val).toLocaleDateString() : "-";
						}

						// Truncate long values
						if (typeof val === "string" && val.length > 50) {
							val = val.substring(0, 50) + "...";
						}

						// Make memories clickable
						if (table === "memories" && col === "title") {
							html += `<td><a href="#" class="memory-link" data-id="${row.id}">${val || "-"}</a></td>`;
						} else {
							html += `<td>${val ?? "-"}</td>`;
						}
					});
					html += "</tr>";
				});

				html += "</tbody></table>";
				$("#db-content").innerHTML = html;

				// Add click handlers for memory links
				$$(".memory-link").forEach((link) => {
					link.addEventListener("click", (e) => {
						e.preventDefault();
						showMemoryDetail(link.dataset.id);
					});
				});
			}

			async function showMemoryDetail(id) {
				try {
					const res = await fetch(`/db/memory/${id}`);
					const memory = await res.json();

					if (memory.error) {
						alert(memory.error);
						return;
					}

					const html = `
          <h2>[${memory.id}] ${memory.title}</h2>
          <div class="memory-meta">
            <span class="badge">${memory.type}</span>
            <span class="badge">${memory.status}</span>
            <span class="badge">${memory.permission}</span>
          </div>
          ${memory.path ? `<p class="memory-path">${memory.path}</p>` : ""}
          <div class="memory-content">${DOMPurify.sanitize(marked.parse(memory.content))}</div>
        `;

					$("#memory-detail").innerHTML = html;
					$("#memory-modal").classList.remove("hidden");

					// Highlight code
					$$("#memory-detail pre code").forEach((block) => {
						Prism.highlightElement(block);
					});
				} catch (e) {
					alert("Error loading memory: " + e.message);
				}
			}

			// === Event Listeners ===
			$("#table-select").addEventListener("change", loadTableData);
			$("#project-filter").addEventListener("change", loadTableData);
			$("#refresh-db").addEventListener("click", () => {
				loadStats();
				loadTableData();
			});

			$("#modal-close").addEventListener("click", () => {
				$("#memory-modal").classList.add("hidden");
			});

			$("#memory-modal").addEventListener("click", (e) => {
				if (e.target === $("#memory-modal")) {
					$("#memory-modal").classList.add("hidden");
				}
			});

			$("#save-to-minni").addEventListener("click", () => {
				// TODO: Implement save to minni
				// This will call a tool or endpoint to save the canvas content as a memory
				alert("Save to Minni - Coming soon!\n\nContent length: " + canvasContent.length + " chars");
			});

			// === Init ===
			connectCanvasSSE();
			loadStats();
		</script>
	</body>
</html>
